import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:math';

void main() {
  runApp(GraphEditorApp());
}

class GraphEditorApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Graph Editor',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        brightness: Brightness.dark,
        scaffoldBackgroundColor: Color(0xFF1a1a1a),
        appBarTheme: AppBarTheme(
          backgroundColor: Color(0xFF2196F3),
          elevation: 0,
        ),
      ),
      home: GraphEditor(),
    );
  }
}

class Node {
  final int id;
  final String name;
  Offset position;
  Node({required this.id, required this.name, required this.position});
}

class Edge {
  final Node source;
  final Node target;
  Edge({required this.source, required this.target});
}

class GraphEditor extends StatefulWidget {
  @override
  _GraphEditorState createState() => _GraphEditorState();
}

class _GraphEditorState extends State<GraphEditor> {
  List<Node> nodes = [];
  List<Edge> edges = [];
  int nextId = 0;
  Node? selectedNode; // Track selected node for edge creation
  Node? draggingNode; // Add this property to track dragging
  Offset? dragOffset;  // Add this to maintain relative drag position
  final FocusNode _focusNode = FocusNode();
  Edge? selectedEdge; // Add this property to track selected edge

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  void _deleteSelected() {
    setState(() {
      if (selectedNode != null) {
        edges.removeWhere((edge) =>
          edge.source == selectedNode || edge.target == selectedNode);
        nodes.remove(selectedNode);
        selectedNode = null;
      } else if (selectedEdge != null) {
        edges.remove(selectedEdge);
        selectedEdge = null;
      }
    });
  }

  String _exportDOT() {
    StringBuffer dot = StringBuffer();
    dot.writeln('digraph G {');
    for (var node in nodes) {
      dot.writeln('  node${node.id} [label="${node.name}"];');
    }
    for (var edge in edges) {
      dot.writeln('  node${edge.source.id} -> node${edge.target.id};');
    }
    dot.writeln('}');
    return dot.toString();
  }

  String _exportXML() {
    StringBuffer xml = StringBuffer();
    xml.writeln('<Graph>');
    for (var node in nodes) {
      xml.writeln(
          '  <Node id="${node.id}" name="${node.name}" x="${node.position.dx}" y="${node.position.dy}" />');
    }
    xml.writeln('  <Edges>');
    for (var edge in edges) {
      xml.writeln('    <Edge source="${edge.source.id}" target="${edge.target.id}" />');
    }
    xml.writeln('  </Edges>');
    xml.writeln('</Graph>');
    return xml.toString();
  }

  Node? _findNodeAt(Offset position) {
    for (var node in nodes.reversed) {
      if ((node.position - position).distance < 25) {
        return node;
      }
    }
    return null;
  }

  Edge? _findEdgeAt(Offset position) {
    for (var edge in edges.reversed) {
      if (_isPointNearEdge(position, edge.source.position, edge.target.position)) {
        return edge;
      }
    }
    return null;
  }

  bool _isPointNearEdge(Offset point, Offset start, Offset end) {
    final double threshold = 10.0;

    // Vector from start to end
    final vec = end - start;
    final length = vec.distance;

    // Vector from start to point
    final pointVec = point - start;

    // Calculate projection
    final t = (pointVec.dx * vec.dx + pointVec.dy * vec.dy) / (length * length);

    // Check if projection is within line segment
    if (t < 0 || t > 1) return false;

    // Calculate closest point on line
    final projection = Offset(
      start.dx + t * vec.dx,
      start.dy + t * vec.dy,
    );

    // Check distance to line
    return (point - projection).distance < threshold;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        // title: Text('Graph Editor'),
        actions: [
          IconButton(
            icon: Icon(Icons.code),
            tooltip: 'Export DOT',
            onPressed: () {
              final dot = _exportDOT();
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: Text("Export DOT"),
                  content: SingleChildScrollView(child: Text(dot)),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: Text("Close"),
                    ),
                  ],
                ),
              );
            },
          ),
          IconButton(
            icon: Icon(Icons.code_off),
            tooltip: 'Export XML',
            onPressed: () {
              final xml = _exportXML();
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: Text("Export XML"),
                  content: SingleChildScrollView(child: Text(xml)),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: Text("Close"),
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
      body: KeyboardListener(
        focusNode: _focusNode,
        onKeyEvent: (event) {
          if (event is KeyDownEvent) {
            if (event.logicalKey == LogicalKeyboardKey.backspace ||
                event.logicalKey == LogicalKeyboardKey.delete) {
              _deleteSelected();
            }
          }
        },
        child: GestureDetector(
          onPanStart: (details) {
            final tappedNode = _findNodeAt(details.localPosition);
            if (tappedNode != null) {
              setState(() {
                draggingNode = tappedNode;
                dragOffset = tappedNode.position - details.localPosition;
              });
            }
          },
          onPanUpdate: (details) {
            if (draggingNode != null) {
              setState(() {
                draggingNode!.position = details.localPosition + dragOffset!;
              });
            }
          },
          onPanEnd: (details) {
            setState(() {
              draggingNode = null;
              dragOffset = null;
            });
          },
          onTapDown: (details) {
            // Ensure focus for keyboard events
            _focusNode.requestFocus();
            if (draggingNode != null) return; // Ignore taps while dragging

            final tappedNode = _findNodeAt(details.localPosition);
            final tappedEdge = _findEdgeAt(details.localPosition);

            setState(() {
              if (tappedNode != null) {
                selectedEdge = null;
                if (selectedNode == null) {
                  selectedNode = tappedNode;
                } else {
                  if (selectedNode != tappedNode) {
                    edges.add(Edge(source: selectedNode!, target: tappedNode));
                  }
                  selectedNode = null;
                }
              } else if (tappedEdge != null) {
                selectedNode = null;
                selectedEdge = tappedEdge;
              } else {
                selectedNode = null;
                selectedEdge = null;
                nodes.add(Node(
                  id: nextId,
                  name: 'Node ${nextId}',
                  position: details.localPosition,
                ));
                nextId++;
              }
            });
          },
          child: CustomPaint(
            painter: GraphPainter(nodes, edges, selectedNode, selectedEdge),
            child: Container(),
          ),
        ),
      ),
    );
  }
}

class GraphPainter extends CustomPainter {
  final List<Node> nodes;
  final List<Edge> edges;
  final Node? selectedNode;
  final Edge? selectedEdge;

  GraphPainter(this.nodes, this.edges, this.selectedNode, this.selectedEdge);

  void _drawArrow(Canvas canvas, Offset start, Offset end, Paint paint) {
    final double arrowSize = 5.0;
    final double angle = 25.0 * (3.14159 / 180.0); // 25 degrees in radians

    // Calculate the direction vector
    var direction = (end - start);
    direction = direction / direction.distance;

    // Calculate arrow base point - move back from end by node radius + arrow size
    var basePoint = end - direction * (25 + arrowSize);

    // Calculate arrow points
    var leftPoint = basePoint + Offset(
      arrowSize * (direction.dy * cos(angle) - direction.dx * sin(angle)),
      arrowSize * (-direction.dx * cos(angle) - direction.dy * sin(angle))
    );
    var rightPoint = basePoint + Offset(
      arrowSize * (-direction.dy * cos(angle) - direction.dx * sin(angle)),
      arrowSize * (direction.dx * cos(angle) - direction.dy * sin(angle))
    );

    // Draw arrow line
    canvas.drawLine(start, basePoint, paint);

    // Draw arrowhead
    final Path path = Path()
      ..moveTo(basePoint.dx, basePoint.dy)
      ..lineTo(leftPoint.dx, leftPoint.dy)
      ..lineTo(end.dx, end.dy)
      ..lineTo(rightPoint.dx, rightPoint.dy)
      ..close();
    canvas.drawPath(path, paint..style = PaintingStyle.fill);
  }

  @override
  void paint(Canvas canvas, Size size) {
    final nodePaint = Paint()
      ..color = Color(0xFF2196F3)
      ..style = PaintingStyle.fill
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 2);

    final nodeStrokePaint = Paint()
      ..color = Colors.blue.shade300
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;

    final selectedNodePaint = Paint()
      ..color = Colors.blue.shade400
      ..style = PaintingStyle.fill;

    final edgePaint = Paint()
      ..color = Colors.white.withOpacity(0.7)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    // Update edge paint to include selection state
    final selectedEdgePaint = Paint()
      ..color = Colors.white
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke;

    // Draw edges with selection highlighting
    for (var edge in edges) {
      final isSelected = edge == selectedEdge;
      final paint = isSelected ? selectedEdgePaint : edgePaint;

      // Draw glow effect for selected edge
      if (isSelected) {
        _drawArrow(canvas, edge.source.position, edge.target.position, Paint()
          ..color = Colors.white.withOpacity(0.3)
          ..strokeWidth = 6
          ..style = PaintingStyle.stroke
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, 3));
      }

      _drawArrow(canvas, edge.source.position, edge.target.position, paint);
    }

    // Draw nodes with enhanced glow effect
    for (var node in nodes) {
      if (node == selectedNode) {
        // Enhanced glow effect for selected node
        canvas.drawCircle(node.position, 32, Paint()
          ..color = Colors.blue.shade300.withOpacity(0.4)
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, 12));

        canvas.drawCircle(node.position, 30, Paint()
          ..color = Colors.blue.shade200.withOpacity(0.3)
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, 8));
      } else {
        // Normal glow for unselected nodes
        canvas.drawCircle(node.position, 28, Paint()
          ..color = Colors.blue.withOpacity(0.2)
          ..maskFilter = MaskFilter.blur(BlurStyle.normal, 8));
      }

      // Draw main circle
      canvas.drawCircle(node.position, 25,
        node == selectedNode ? selectedNodePaint : nodePaint);

      // Draw stroke with enhanced highlight
      canvas.drawCircle(node.position, 25, Paint()
        ..color = node == selectedNode ? Colors.white.withOpacity(0.8) : Colors.blue.shade300
        ..style = PaintingStyle.stroke
        ..strokeWidth = node == selectedNode ? 3 : 2);

      // Draw text with enhanced contrast for selected node
      final textSpan = TextSpan(
        text: node.name,
        style: TextStyle(
          color: node == selectedNode ? Colors.white : Colors.white.withOpacity(0.9),
          fontSize: node == selectedNode ? 14 : 12,
          fontWeight: node == selectedNode ? FontWeight.bold : FontWeight.w500,
          shadows: [
            Shadow(
              color: Colors.black.withOpacity(0.5),
              offset: Offset(0, 1),
              blurRadius: 3,
            ),
          ],
        ),
      );

      final textPainter = TextPainter(
        text: textSpan,
        textAlign: TextAlign.center,
        textDirection: TextDirection.ltr,
      );

      textPainter.layout(minWidth: 0, maxWidth: 50);
      final offset = node.position -
          Offset(textPainter.width / 2, textPainter.height / 2);
      textPainter.paint(canvas, offset);
    }
  }

  @override
  bool shouldRepaint(GraphPainter oldDelegate) => true;
}
